{"/home/travis/build/npmtest/node-npmtest-cordova-plugin-qrscanner/test.js":"/* istanbul instrument in package npmtest_cordova_plugin_qrscanner */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-qrscanner/lib.npmtest_cordova_plugin_qrscanner.js":"/* istanbul instrument in package npmtest_cordova_plugin_qrscanner */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_cordova_plugin_qrscanner = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_cordova_plugin_qrscanner = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-qrscanner/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-cordova-plugin-qrscanner && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_cordova_plugin_qrscanner */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_cordova_plugin_qrscanner\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_cordova_plugin_qrscanner.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_cordova_plugin_qrscanner.rollup.js'] =\n            local.assetsDict['/assets.npmtest_cordova_plugin_qrscanner.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_cordova_plugin_qrscanner.__dirname + '/lib.npmtest_cordova_plugin_qrscanner.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-qrscanner/node_modules/cordova-plugin-qrscanner/gulpfile.js":"'use strict';\n\nconst gulp = require('gulp');\nconst insert = require('gulp-insert');\nconst fs= require('fs');\n\nconst remap = fs.readFileSync('src/common/src/cordova-remap.js', 'utf-8');\n\nfunction webpack(config, callback){\n  const exec = require('child_process').exec;\n  exec(__dirname + '/node_modules/.bin/webpack --config ' + config, (error, stdout, stderr) => {\n    console.log(stdout);\n    console.log(stderr);\n    callback(error);\n  });\n}\n\ngulp.task('prepack', function(cb){\n  webpack('webpack.prepack.config.js', cb);\n});\n\ngulp.task('webpack-cordova', ['prepack'], function(cb){\n  webpack('webpack.cordova.config.js', cb);\n});\n\ngulp.task('dist', ['prepack'], function(cb){\n  webpack('webpack.library.config.js', cb);\n});\n\ngulp.task('remap', ['webpack-cordova'], function () {\n  return gulp.src(['dist/plugin.min.js', 'dist/www.min.js'])\n  .pipe(insert.prepend(remap))\n  .pipe(gulp.dest('dist'));\n});\n\ngulp.task('plugin', ['remap'], function () {\n  return gulp.src(['dist/plugin.min.js'])\n  .pipe(gulp.dest('src/browser'));\n});\n\ngulp.task('www', ['remap'], function () {\n  return gulp.src(['dist/www.min.js'])\n  .pipe(gulp.dest('www'));\n});\n\ngulp.task('default', ['dist', 'plugin', 'www']);\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-qrscanner/node_modules/cordova-plugin-qrscanner/webpack.cordova.config.js":"const webpack = require('webpack');\n\nmodule.exports = {\n  entry: {\n    plugin: './src/browser/src/cordova-plugin.js',\n    www: './src/common/src/cordova-www.js'\n  },\n  output: {\n    path: './dist',\n    filename: '[name].min.js'\n  },\n  externals: {\n    \"webpack/cordova\": \"cordova\",\n    \"webpack/cordova/require\": \"cordovaRequire\",\n    \"webpack/cordova/exports\": \"cordovaExports\",\n    \"webpack/cordova/module\": \"cordovaModule\"\n  },\n  plugins: [\n    // new webpack.optimize.UglifyJsPlugin({\n    //   comments: false\n    // })\n  ]\n}\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-qrscanner/node_modules/cordova-plugin-qrscanner/webpack.library.config.js":"const webpack = require('webpack');\n\nmodule.exports = {\n  devtool: 'source-map',\n  entry: {\n    library: './src/browser/src/library.js'\n  },\n  output: {\n      path: './dist',\n      filename: 'cordova-plugin-qrscanner-lib.min.js',\n      library: 'QRScanner',\n      libraryTarget: 'umd',\n      umdNamedDefine: true\n  },\n  plugins: [\n    new webpack.optimize.UglifyJsPlugin({\n      comments: false,\n      sourceMap: true\n    })\n  ]\n}\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-qrscanner/node_modules/cordova-plugin-qrscanner/webpack.prepack.config.js":"const webpack = require('webpack');\n\nmodule.exports = {\n  entry: {\n    worker: './src/browser/src/worker.js',\n  },\n  output: {\n    path: './src/browser',\n    filename: 'worker.min.js'\n  },\n  plugins: [\n    new webpack.optimize.UglifyJsPlugin({\n      comments: false\n    })\n  ]\n}\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-qrscanner/node_modules/cordova-plugin-qrscanner/hooks/windows/check-arch.js":"module.exports = function(ctx) {\n    if (ctx.opts && ctx.opts.platforms && ctx.opts.platforms.indexOf('windows') > -1\n        && ctx.opts.options) {\n        var path = require('path');\n        var shell = ctx.requireCordovaModule('shelljs');\n        var nopt = ctx.requireCordovaModule('nopt');\n\n        // parse and validate args\n        var args = nopt({\n            'archs': [String],\n            'appx': String,\n            'phone': Boolean,\n            'win': Boolean,\n            'bundle': Boolean,\n            'packageCertificateKeyFile': String,\n            'packageThumbprint': String,\n            'publisherId': String,\n            'buildConfig': String\n        }, {}, ctx.opts.options.argv, 0);\n\n        // Check if --appx flag is passed so that we have a project build version override:  \n        var isWin10 = args.appx && args.appx.toLowerCase() === 'uap';\n\n        // Else check \"windows-target-version\" preference:\n        if (!isWin10) {\n            var configXml = shell.ls(path.join(ctx.opts.projectRoot, 'config.xml'))[0];\n\n            var reTargetVersion = /<preference\\s+name=\"windows-target-version\"\\s+value=\"(.+)\"\\s*\\/>/i;\n            var targetVersion = shell.grep(reTargetVersion, configXml);\n\n            var result = reTargetVersion.exec(targetVersion);\n            if (result !== null) {\n                var match = result[1];\n                isWin10 = parseInt(match.split('.'), 10) > 8;\n            }\n        }\n\n        // Non-AnyCPU arch is required for Windows 10 (UWP) projects only:\n        if (isWin10) {\n            var rawArchs = ctx.opts.options.archs || args.archs;\n            var archs = rawArchs ? rawArchs.split(' ') : [];\n\n            // Avoid \"anycpu\" arch:\n            if (archs.length === 0 || archs.some(function (item) {\n                return item.toLowerCase() === 'anycpu';\n            })) {\n                throw new Error('You must specify an architecture to include the proper ZXing library version.'\n                + '\\nUse \\'cordova run windows -- --arch=\"x64\"\\' or \\'cordova run windows -- --arch=\"arm\" --phone --device\\' for example.');\n            }\n        }\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-qrscanner/node_modules/cordova-plugin-qrscanner/src/browser/src/cordova-plugin.js":"var cordovaRequire = require('webpack/cordova/require');\nvar cordovaModule = require('webpack/cordova/module');\n\nvar createQRScannerInternal = require('./createQRScannerInternal.js');\n\ncordovaModule.exports = createQRScannerInternal();\ncordovaRequire('cordova/exec/proxy').add('QRScanner', cordovaModule.exports);\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-qrscanner/node_modules/cordova-plugin-qrscanner/src/browser/src/createQRScannerInternal.js":"require('webrtc-adapter');\nvar workerScript = require(\"raw-loader!../worker.min.js\");\n\nmodule.exports = function(){\n\n  var ELEMENTS = {\n    preview: 'cordova-plugin-qrscanner-video-preview',\n    still: 'cordova-plugin-qrscanner-still'\n  };\n  var ZINDEXES = {\n    preview: -100,\n    still: -99\n  };\n  var backCamera = null;\n  var frontCamera = null;\n  var currentCamera = 0;\n  var activeMediaStream = null;\n  var scanning = false;\n  var previewing = false;\n  var scanWorker = null;\n  var thisScanCycle = null;\n  var nextScan = null;\n  var cancelNextScan = null;\n\n  // standard screen widths/heights, from 4k down to 320x240\n  // widths and heights are each tested separately to account for screen rotation\n  var standardWidthsAndHeights = [\n    5120, 4096, 3840, 3440, 3200, 3072, 3000, 2880, 2800, 2736, 2732, 2560,\n    2538, 2400, 2304, 2160, 2100, 2048, 2000, 1920, 1856, 1824, 1800, 1792,\n    1776, 1728, 1700, 1680, 1600, 1536, 1440, 1400, 1392, 1366, 1344, 1334,\n    1280, 1200, 1152, 1136, 1120, 1080, 1050, 1024, 1000, 960, 900, 854, 848,\n    832, 800, 768, 750, 720, 640, 624, 600, 576, 544, 540, 512, 480, 320, 240\n  ];\n\n  var facingModes = [\n    'environment',\n    'user'\n  ];\n\n  //utils\n  function killStream(mediaStream){\n    mediaStream.getTracks().forEach(function(track){\n      track.stop();\n    });\n  }\n\n  // For performance, we test best-to-worst constraints. Once we find a match,\n  // we move to the next test. Since `ConstraintNotSatisfiedError`s are thrown\n  // much faster than streams can be started and stopped, the scan is much\n  // faster, even though it may iterate through more constraint objects.\n  function getCameraSpecsById(deviceId){\n\n    // return a getUserMedia Constraints\n    function getConstraintObj(deviceId, facingMode, width, height){\n      var obj = { audio: false, video: {} };\n      obj.video.deviceId = {exact: deviceId};\n      if(facingMode) {\n        obj.video.facingMode = {exact: facingMode};\n      }\n      if(width) {\n        obj.video.width = {exact: width};\n      }\n      if(height) {\n        obj.video.height = {exact: height};\n      }\n      return obj;\n    }\n\n    var facingModeConstraints = facingModes.map(function(mode){\n    \treturn getConstraintObj(deviceId, mode);\n    });\n    var widthConstraints = standardWidthsAndHeights.map(function(width){\n    \treturn getConstraintObj(deviceId, null, width);\n    });\n    var heightConstraints = standardWidthsAndHeights.map(function(height){\n    \treturn getConstraintObj(deviceId, null, null, height);\n    });\n\n    // create a promise which tries to resolve the best constraints for this deviceId\n    // rather than reject, failures return a value of `null`\n    function getFirstResolvingConstraint(constraintsBestToWorst){\n      return new Promise(function(resolveBestConstraints){\n        // build a chain of promises which either resolves or continues searching\n        return constraintsBestToWorst.reduce(function(chain, next){\n          return chain.then(function(searchState){\n            if(searchState.found){\n              // The best working constraint was found. Skip further tests.\n              return searchState;\n            } else {\n              searchState.nextConstraint = next;\n              return window.navigator.mediaDevices.getUserMedia(searchState.nextConstraint).then(function(mediaStream){\n                // We found the first working constraint object, now we can stop\n                // the stream and short-circuit the search.\n                killStream(mediaStream);\n                searchState.found = true;\n                return searchState;\n              }, function(){\n                // didn't get a media stream. The search continues:\n                return searchState;\n              });\n            }\n          });\n        }, Promise.resolve({\n          // kick off the search:\n          found: false,\n          nextConstraint: {}\n        })).then(function(searchState){\n          if(searchState.found){\n            resolveBestConstraints(searchState.nextConstraint);\n          } else {\n            resolveBestConstraints(null);\n          }\n        });\n      });\n    }\n\n    return getFirstResolvingConstraint(facingModeConstraints).then(function(facingModeSpecs){\n      return getFirstResolvingConstraint(widthConstraints).then(function(widthSpecs){\n        return getFirstResolvingConstraint(heightConstraints).then(function(heightSpecs){\n          return {\n            deviceId: deviceId,\n            facingMode: facingModeSpecs === null ? null : facingModeSpecs.video.facingMode.exact,\n            width: widthSpecs === null ? null : widthSpecs.video.width.exact,\n            height: heightSpecs === null ? null : heightSpecs.video.height.exact\n          };\n        });\n      });\n    });\n  }\n\n  function chooseCameras(){\n    var devices = window.navigator.mediaDevices.enumerateDevices();\n    return devices.then(function(mediaDeviceInfoList){\n      var videoDeviceIds = mediaDeviceInfoList.filter(function(elem){\n        return elem.kind === 'videoinput';\n      }).map(function(elem){\n        return elem.deviceId;\n      });\n      return videoDeviceIds;\n    }).then(function(videoDeviceIds){\n      // there is no standardized way for us to get the specs of each camera\n      // (due to concerns over user fingerprinting), so we're forced to\n      // iteratively test each camera for it's capabilities\n      var searches = [];\n      videoDeviceIds.forEach(function(id){\n        searches.push(getCameraSpecsById(id));\n      });\n      return Promise.all(searches);\n    }).then(function(cameraSpecsArray){\n      return cameraSpecsArray.filter(function(camera){\n        // filter out any cameras where width and height could not be captured\n        if(camera !== null && camera.width !== null && camera.height !== null){\n          return true;\n        }\n      }).sort(function(a, b){\n        // sort cameras from highest resolution (by width) to lowest\n        return b.width - a.width;\n      });\n    }).then(function(bestToWorstCameras){\n      var backCamera = null,\n          frontCamera = null;\n      // choose backCamera\n      for(var i = 0; i < bestToWorstCameras.length; i++){\n        if (bestToWorstCameras[i].facingMode === 'environment'){\n          backCamera = bestToWorstCameras[i];\n          // (shouldn't be used for frontCamera)\n          bestToWorstCameras.splice(i, 1);\n          break;\n        }\n      }\n      // if no back-facing cameras were found, choose the highest resolution\n      if(backCamera === null){\n        if(bestToWorstCameras.length > 0){\n          backCamera = bestToWorstCameras[0];\n          // (shouldn't be used for frontCamera)\n          bestToWorstCameras.splice(0, 1);\n        } else {\n          // user doesn't have any available cameras\n          backCamera = false;\n        }\n      }\n      if(bestToWorstCameras.length > 0){\n        // frontCamera should simply be the next-best resolution camera\n        frontCamera = bestToWorstCameras[0];\n      } else {\n        // user doesn't have any more cameras\n        frontCamera = false;\n      }\n      return {\n        backCamera: backCamera,\n        frontCamera: frontCamera\n      };\n    });\n  }\n\n  function mediaStreamIsActive(){\n    return activeMediaStream !== null;\n  }\n\n  function killActiveMediaStream(){\n    killStream(activeMediaStream);\n    activeMediaStream = null;\n  }\n\n  function getVideoPreview(){\n    return document.getElementById(ELEMENTS.preview);\n  }\n\n  function getImg(){\n    return document.getElementById(ELEMENTS.still);\n  }\n\n  function getCurrentCameraIndex(){\n    return currentCamera;\n  }\n\n  function getCurrentCamera(){\n    return currentCamera === 1 ? frontCamera : backCamera;\n  }\n\n  function bringStillToFront(){\n    var img = getImg();\n    if(img){\n      img.style.visibility = 'visible';\n      previewing = false;\n    }\n  }\n\n  function bringPreviewToFront(){\n    var img = getImg();\n    if(img){\n      img.style.visibility = 'hidden';\n      previewing = true;\n    }\n  }\n\n  function isInitialized(){\n    return backCamera !== null;\n  }\n\n  function canChangeCamera(){\n    return !!backCamera && !!frontCamera;\n  }\n\n  function calcStatus(){\n    return {\n      // !authorized means the user either has no camera or has denied access.\n      // This would leave a value of `null` before prepare(), and `false` after.\n      authorized: (backCamera !== null && backCamera !== false)? '1': '0',\n      // No applicable API\n      denied: '0',\n      // No applicable API\n      restricted: '0',\n      prepared: isInitialized() ? '1' : '0',\n      scanning: scanning? '1' : '0',\n      previewing: previewing? '1' : '0',\n      // We leave this true after prepare() to match the mobile experience as\n      // closely as possible. (Without additional covering, the preview will\n      // always be visible to the user).\n      showing: getVideoPreview()? '1' : '0',\n      // No applicable API\n      lightEnabled: '0',\n      // No applicable API\n      canOpenSettings: '0',\n      // No applicable API\n      canEnableLight: '0',\n      canChangeCamera: canChangeCamera() ? '1' : '0',\n      currentCamera: currentCamera.toString()\n    };\n  }\n\n  function startCamera(success, error){\n      var currentCameraIndex = getCurrentCameraIndex();\n      var currentCamera = getCurrentCamera();\n      window.navigator.mediaDevices.getUserMedia({\n        audio: false,\n        video: {\n          deviceId: {exact: currentCamera.deviceId},\n          width: {ideal: currentCamera.width},\n          height: {ideal: currentCamera.height}\n        }\n      }).then(function(mediaStream){\n        activeMediaStream = mediaStream;\n        var video = getVideoPreview();\n        video.src = URL.createObjectURL(mediaStream);\n        success(calcStatus());\n      }, function(err){\n        // something bad happened\n        err = null;\n        var code = currentCameraIndex? 4 : 3;\n        error(code); // FRONT_CAMERA_UNAVAILABLE : BACK_CAMERA_UNAVAILABLE\n      });\n  }\n\n  function getTempCanvasAndContext(videoElement){\n    var tempCanvas = document.createElement('canvas');\n    var camera = getCurrentCamera();\n    tempCanvas.height = camera.height;\n    tempCanvas.width = camera.width;\n    var tempCanvasContext = tempCanvas.getContext('2d');\n    tempCanvasContext.drawImage(videoElement, 0, 0, camera.width, camera.height);\n    return {\n      canvas: tempCanvas,\n      context: tempCanvasContext\n    };\n  }\n\n  function getCurrentImageData(videoElement){\n    var snapshot = getTempCanvasAndContext(videoElement);\n    return snapshot.context.getImageData(0, 0, snapshot.canvas.width, snapshot.canvas.height);\n  }\n\n  // take a screenshot of the video preview with a temp canvas\n  function captureCurrentFrame(videoElement){\n    return getTempCanvasAndContext(videoElement).canvas.toDataURL('image/png');\n  }\n\n  function initialize(success, error){\n    if(scanWorker === null){\n      var workerBlob = new Blob([workerScript],{type: \"text/javascript\"});\n      scanWorker = new Worker(URL.createObjectURL(workerBlob));\n    }\n    if(!getVideoPreview()){\n      // prepare DOM (sync)\n      var videoPreview = document.createElement('video');\n      videoPreview.setAttribute('autoplay', 'autoplay');\n      videoPreview.setAttribute('id', ELEMENTS.preview);\n      videoPreview.setAttribute('style', 'display:block;position:fixed;top:50%;left:50%;' +\n      'width:auto;height:auto;min-width:100%;min-height:100%;z-index:' + ZINDEXES.preview +\n      ';-moz-transform: translateX(-50%) translateY(-50%);-webkit-transform: ' +\n      'translateX(-50%) translateY(-50%);transform:translateX(-50%) translateY(-50%);' +\n      'background-size:cover;background-position:50% 50%;background-color:#FFF;');\n      videoPreview.addEventListener('loadeddata', function(){\n        bringPreviewToFront();\n      });\n\n      var stillImg = document.createElement('div');\n      stillImg.setAttribute('id', ELEMENTS.still);\n      stillImg.setAttribute('style', 'display:block;position:fixed;top:50%;left:50%;visibility: hidden;' +\n      'width:auto;height:auto;min-width:100%;min-height:100%;z-index:' + ZINDEXES.still +\n      ';-moz-transform: translateX(-50%) translateY(-50%);-webkit-transform: ' +\n      'translateX(-50%) translateY(-50%);transform:translateX(-50%) translateY(-50%);' +\n      'background-size:cover;background-position:50% 50%;background-color:#FFF;');\n\n      document.body.appendChild(videoPreview);\n      document.body.appendChild(stillImg);\n    }\n    if(backCamera === null){\n      // set instance cameras\n      chooseCameras().then(function(cameras){\n        backCamera = cameras.backCamera;\n        frontCamera = cameras.frontCamera;\n        if(backCamera !== false){\n          success();\n        } else {\n          error(5); // CAMERA_UNAVAILABLE\n        }\n      }, function(err){\n        // something bad happened\n        err = null;\n        error(0); // UNEXPECTED_ERROR\n      });\n    } else if (backCamera === false){\n      error(5); // CAMERA_UNAVAILABLE\n    } else {\n      success();\n    }\n  }\n\n  /*\n   *  --- Begin Public API ---\n   */\n\n  function prepare(success, error){\n    initialize(function(){\n      // return status on success\n      success(calcStatus());\n    },\n    // pass errors through\n    error);\n  }\n\n  function show(success, error){\n    function showCamera(){\n      if(!mediaStreamIsActive()){\n        startCamera(success, error);\n      } else {\n        success(calcStatus());\n      }\n    }\n    if(!isInitialized()){\n      initialize(function(){\n        // on successful initialization, attempt to showCamera\n        showCamera();\n      },\n      // pass errors through\n      error);\n    } else {\n      showCamera();\n    }\n  }\n\n  function hide(success, error){\n    error = null; // should never error\n    if(mediaStreamIsActive()){\n      killActiveMediaStream();\n    }\n    var video = getVideoPreview();\n    if(video){\n      video.src = '';\n    }\n    success(calcStatus());\n  }\n\n  function scan(success, error) {\n    // initialize and start video preview if not already active\n    show(function(ignore){\n      // ignore success output â€“ `scan` method callback should be passed the decoded data\n      ignore = null;\n      var video = getVideoPreview();\n      var returned = false;\n      scanning = true;\n      scanWorker.onmessage = function(event){\n        var obj = event.data;\n        if(obj.result && !returned){\n          returned = true;\n          thisScanCycle = null;\n          success(obj.result);\n        }\n      };\n      thisScanCycle = function(){\n        scanWorker.postMessage(getCurrentImageData(video));\n        if(cancelNextScan !== null){\n          // avoid race conditions, always clear before starting a cycle\n          cancelNextScan();\n        }\n        // interval in milliseconds at which to try decoding the QR code\n        var SCAN_INTERVAL = window.QRScanner_SCAN_INTERVAL || 130;\n        // this value can be adjusted on-the-fly (while a scan is active) to\n        // balance scan speed vs. CPU/power usage\n        nextScan = window.setTimeout(thisScanCycle, SCAN_INTERVAL);\n        cancelNextScan = function(sendError){\n          window.clearTimeout(nextScan);\n          nextScan = null;\n          cancelNextScan = null;\n          if(sendError){\n            error(6); // SCAN_CANCELED\n          }\n        };\n      };\n      thisScanCycle();\n    }, error);\n  }\n\n  function cancelScan(success, error){\n    error = null; // should never error\n    if(cancelNextScan !== null){\n      cancelNextScan(true);\n    }\n    scanning = false;\n    if(typeof success === \"function\"){\n      success(calcStatus());\n    }\n  }\n\n  function pausePreview(success, error){\n    error = null; // should never error\n    if(mediaStreamIsActive()){\n      // pause scanning too\n      if(cancelNextScan !== null){\n        cancelNextScan();\n      }\n      var video = getVideoPreview();\n      video.pause();\n      var img = new Image();\n      img.src = captureCurrentFrame(video);\n      getImg().style.backgroundImage = 'url(' + img.src + ')';\n      bringStillToFront();\n      // kill the active stream to turn off the privacy light (the screenshot\n      // in the stillImg will remain visible)\n      killActiveMediaStream();\n      success(calcStatus());\n    } else {\n      success(calcStatus());\n    }\n  }\n\n  function resumePreview(success, error){\n    // if a scan was happening, resume it\n    if(thisScanCycle !== null){\n      thisScanCycle();\n    }\n    show(success, error);\n  }\n\n  function enableLight(success, error){\n    error(7); //LIGHT_UNAVAILABLE\n  }\n\n  function disableLight(success, error){\n    error(7); //LIGHT_UNAVAILABLE\n  }\n\n  function useCamera(success, error, array){\n    var requestedCamera = array[0];\n    var initialized = isInitialized();\n    if(requestedCamera !== currentCamera){\n      if(initialized && requestedCamera === 1 && !canChangeCamera()){\n          error(4); //FRONT_CAMERA_UNAVAILABLE\n      } else {\n        currentCamera = requestedCamera;\n        if(initialized){\n          hide(function(status){\n            // Don't need this one\n            status = null;\n          });\n          show(success, error);\n        } else {\n          success(calcStatus());\n        }\n      }\n    } else {\n      success(calcStatus());\n    }\n  }\n\n  function openSettings(success, error){\n    error(8); //OPEN_SETTINGS_UNAVAILABLE\n  }\n\n  function getStatus(success, error){\n    error = null; // should never error\n    success(calcStatus());\n  }\n\n  // Reset all instance variables to their original state.\n  // This method might be useful in cases where a new camera is available, and\n  // the application needs to force the plugin to chooseCameras() again.\n  function destroy(success, error){\n    error = null; // should never error\n    cancelScan();\n    if(mediaStreamIsActive()){\n      killActiveMediaStream();\n    }\n    backCamera = null;\n    frontCamera = null;\n    var preview = getVideoPreview();\n    var still = getImg();\n    if(preview){\n      preview.remove();\n    }\n    if(still){\n      still.remove();\n    }\n    success(calcStatus());\n  }\n\n  return {\n      prepare: prepare,\n      show: show,\n      hide: hide,\n      scan: scan,\n      cancelScan: cancelScan,\n      pausePreview: pausePreview,\n      resumePreview: resumePreview,\n      enableLight: enableLight,\n      disableLight: disableLight,\n      useCamera: useCamera,\n      openSettings: openSettings,\n      getStatus: getStatus,\n      destroy: destroy\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-qrscanner/node_modules/cordova-plugin-qrscanner/src/browser/src/library.js":"function QRScanner() {\n  var createQRScannerAdapter = require('../../common/src/createQRScannerAdapter.js');\n  var createQRScannerInternal = require('./createQRScannerInternal.js');\n\n  var internal = createQRScannerInternal();\n  var functionList = {\n      prepare: internal.prepare,\n      show: internal.show,\n      hide: internal.hide,\n      scan: internal.scan,\n      cancelScan: internal.cancelScan,\n      pausePreview: internal.pausePreview,\n      resumePreview: internal.resumePreview,\n      enableLight: internal.enableLight,\n      disableLight: internal.disableLight,\n      useCamera: internal.useCamera,\n      openSettings: internal.openSettings,\n      getStatus: internal.getStatus,\n      destroy: internal.destroy\n  };\n\n  // always returns an executable function for use by the internal component\n  // if a callback is provided, use it\n  function getFunc(callback){\n    if(typeof callback === \"function\"){\n      return callback;\n    }\n    return function(){\n      // callback is not needed\n      return;\n    };\n  }\n\n  // shim cordova's functionality for library usage\n  var shimCordova = {\n    exec: function(successCallback, errorCallback, className, functionName, inputArray){\n      if(className !== 'QRScanner' || !functionList[functionName]){\n        return errorCallback(0);\n      }\n      if(inputArray){\n        functionList[functionName](getFunc(successCallback), getFunc(errorCallback), inputArray);\n      } else {\n        functionList[functionName](getFunc(successCallback), getFunc(errorCallback));\n      }\n    }\n  };\n\n  var adapter = createQRScannerAdapter(shimCordova);\n  return adapter;\n}\n\nmodule.exports = new QRScanner();\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-qrscanner/node_modules/cordova-plugin-qrscanner/src/common/src/createQRScannerAdapter.js":"module.exports = function createQRScanner(cordova){\n// The native implementations should return their status as ['string':'string']\n// dictionaries. Boolean values are encoded to '0' and '1', respectively.\nfunction stringToBool(string) {\n  switch (string) {\n    case '1':\n      return true;\n    case '0':\n      return false;\n    default:\n    throw new Error('QRScanner plugin returned an invalid boolean number-string: ' + string);\n  }\n}\n\n// Converts the returned ['string':'string'] dictionary to a status object.\nfunction convertStatus(statusDictionary) {\n  return {\n    authorized: stringToBool(statusDictionary.authorized),\n    denied: stringToBool(statusDictionary.denied),\n    restricted: stringToBool(statusDictionary.restricted),\n    prepared: stringToBool(statusDictionary.prepared),\n    scanning: stringToBool(statusDictionary.scanning),\n    previewing: stringToBool(statusDictionary.previewing),\n    showing: stringToBool(statusDictionary.showing),\n    lightEnabled: stringToBool(statusDictionary.lightEnabled),\n    canOpenSettings: stringToBool(statusDictionary.canOpenSettings),\n    canEnableLight: stringToBool(statusDictionary.canEnableLight),\n    canChangeCamera: stringToBool(statusDictionary.canChangeCamera),\n    currentCamera: parseInt(statusDictionary.currentCamera)\n  };\n}\n\n// Simple utility method to ensure the background is transparent. Used by the\n// plugin to force re-rendering immediately after the native webview background\n// is made transparent.\nfunction clearBackground() {\n  var body = document.body;\n  if (body.style) {\n    body.style.backgroundColor = 'rgba(0,0,0,0.01)';\n    body.style.backgroundImage = '';\n    setTimeout(function() {\n      body.style.backgroundColor = 'transparent';\n    }, 1);\n    if (body.parentNode && body.parentNode.style) {\n      body.parentNode.style.backgroundColor = 'transparent';\n      body.parentNode.style.backgroundImage = '';\n    }\n  }\n}\n\nfunction errorCallback(callback) {\n  if (!callback) {\n    return null;\n  }\n  return function(error) {\n    var errorCode = parseInt(error);\n    var QRScannerError = {};\n    switch (errorCode) {\n      case 0:\n        QRScannerError = {\n          name: 'UNEXPECTED_ERROR',\n          code: 0,\n          _message: 'QRScanner experienced an unexpected error.'\n        };\n        break;\n      case 1:\n        QRScannerError = {\n          name: 'CAMERA_ACCESS_DENIED',\n          code: 1,\n          _message: 'The user denied camera access.'\n        };\n        break;\n      case 2:\n        QRScannerError = {\n          name: 'CAMERA_ACCESS_RESTRICTED',\n          code: 2,\n          _message: 'Camera access is restricted.'\n        };\n        break;\n      case 3:\n        QRScannerError = {\n          name: 'BACK_CAMERA_UNAVAILABLE',\n          code: 3,\n          _message: 'The back camera is unavailable.'\n        };\n        break;\n      case 4:\n        QRScannerError = {\n          name: 'FRONT_CAMERA_UNAVAILABLE',\n          code: 4,\n          _message: 'The front camera is unavailable.'\n        };\n        break;\n      case 5:\n        QRScannerError = {\n          name: 'CAMERA_UNAVAILABLE',\n          code: 5,\n          _message: 'The camera is unavailable.'\n        };\n        break;\n      case 6:\n        QRScannerError = {\n          name: 'SCAN_CANCELED',\n          code: 6,\n          _message: 'Scan was canceled.'\n        };\n        break;\n      case 7:\n        QRScannerError = {\n          name: 'LIGHT_UNAVAILABLE',\n          code: 7,\n          _message: 'The device light is unavailable.'\n        };\n        break;\n      case 8:\n        // Open settings is only available on iOS 8.0+.\n        QRScannerError = {\n          name: 'OPEN_SETTINGS_UNAVAILABLE',\n          code: 8,\n          _message: 'The device is unable to open settings.'\n        };\n        break;\n      default:\n        QRScannerError = {\n          name: 'UNEXPECTED_ERROR',\n          code: 0,\n          _message: 'QRScanner returned an invalid error code.'\n        };\n        break;\n    }\n    callback(QRScannerError);\n  };\n}\n\nfunction successCallback(callback) {\n  if (!callback) {\n    return null;\n  }\n  return function(statusDict) {\n    callback(null, convertStatus(statusDict));\n  };\n}\n\nfunction doneCallback(callback, clear) {\n  if (!callback) {\n    return null;\n  }\n  return function(statusDict) {\n    if (clear) {\n      clearBackground();\n    }\n    callback(convertStatus(statusDict));\n  };\n}\n\nreturn {\n  prepare: function(callback) {\n    cordova.exec(successCallback(callback), errorCallback(callback), 'QRScanner', 'prepare', []);\n  },\n  destroy: function(callback) {\n    cordova.exec(doneCallback(callback, true), null, 'QRScanner', 'destroy', []);\n  },\n  scan: function(callback) {\n    if (!callback) {\n      throw new Error('No callback provided to scan method.');\n    }\n    var success = function(result) {\n      callback(null, result);\n    };\n    cordova.exec(success, errorCallback(callback), 'QRScanner', 'scan', []);\n  },\n  cancelScan: function(callback) {\n    cordova.exec(doneCallback(callback), null, 'QRScanner', 'cancelScan', []);\n  },\n  show: function(callback) {\n    cordova.exec(doneCallback(callback, true), null, 'QRScanner', 'show', []);\n  },\n  hide: function(callback) {\n    cordova.exec(doneCallback(callback, true), null, 'QRScanner', 'hide', []);\n  },\n  pausePreview: function(callback) {\n    cordova.exec(doneCallback(callback), null, 'QRScanner', 'pausePreview', []);\n  },\n  resumePreview: function(callback) {\n    cordova.exec(doneCallback(callback), null, 'QRScanner', 'resumePreview', []);\n  },\n  enableLight: function(callback) {\n    cordova.exec(successCallback(callback), errorCallback(callback), 'QRScanner', 'enableLight', []);\n  },\n  disableLight: function(callback) {\n    cordova.exec(successCallback(callback), errorCallback(callback), 'QRScanner', 'disableLight', []);\n  },\n  useCamera: function(index, callback) {\n    cordova.exec(successCallback(callback), errorCallback(callback), 'QRScanner', 'useCamera', [index]);\n  },\n  useFrontCamera: function(callback) {\n    var frontCamera = 1;\n    if (callback) {\n      this.useCamera(frontCamera, callback);\n    } else {\n      cordova.exec(null, null, 'QRScanner', 'useCamera', [frontCamera]);\n    }\n  },\n  useBackCamera: function(callback) {\n    var backCamera = 0;\n    if (callback) {\n      this.useCamera(backCamera, callback);\n    } else {\n      cordova.exec(null, null, 'QRScanner', 'useCamera', [backCamera]);\n    }\n  },\n  openSettings: function(callback) {\n    if (callback) {\n      cordova.exec(successCallback(callback), errorCallback(callback), 'QRScanner', 'openSettings', []);\n    } else {\n      cordova.exec(null, null, 'QRScanner', 'openSettings', []);\n    }\n  },\n  getStatus: function(callback) {\n    if (!callback) {\n      throw new Error('No callback provided to getStatus method.');\n    }\n    cordova.exec(doneCallback(callback), null, 'QRScanner', 'getStatus', []);\n  }\n};\n};\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-qrscanner/node_modules/cordova-plugin-qrscanner/src/browser/src/worker.js":"/*global module:true, postMessage:false, onmessage:true*/\n\nmodule = {};\nvar QrCode = require('qrcode-reader').default;\nvar qr = new QrCode();\nqr.callback = function(result, err){\n\tpostMessage({result: result, err: err});\n};\nonmessage = function(event){\n\tvar imageData = event.data;\n  qr.decode(imageData);\n};\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-qrscanner/node_modules/cordova-plugin-qrscanner/src/common/src/cordova-remap.js":"// This file is generated by `npm run build`.\n\n/*global exports:false*/\n/*jshint unused:false */\n// remap parameter names from cordova.define\n// see `externals` in webpack.cordova.config.js\nvar cordovaRequire = require;\nvar cordovaExports = exports;\nvar cordovaModule = module;\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-qrscanner/node_modules/cordova-plugin-qrscanner/src/common/src/cordova-www.js":"var globalCordova = require('webpack/cordova');\nvar cordovaModule = require('webpack/cordova/module');\n\nvar createQRScannerAdapter = require('./createQRScannerAdapter.js');\n\n// pass in global cordova object to expose cordova.exec\nvar QRScannerAdapter = createQRScannerAdapter(globalCordova);\ncordovaModule.exports = QRScannerAdapter;\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-qrscanner/node_modules/cordova-plugin-qrscanner/src/windows/lib/preview.js":"  const urlutil = require('cordova/urlutil');\n\n  let preview;\n\n  function create() {\n\n    if (preview) {\n      throw 'preview already exists';\n    }\n\n    let capturePreviewFrameStyle = document.createElement('link');\n    capturePreviewFrameStyle.rel = \"stylesheet\";\n    capturePreviewFrameStyle.type = \"text/css\";\n    capturePreviewFrameStyle.href = urlutil.makeAbsolute(\"/www/css/plugin-qrscanner-preview.css\");\n    document.head.appendChild(capturePreviewFrameStyle);\n\n    let capturePreviewFrame = document.createElement('div');\n    capturePreviewFrame.className = \"barcode-scanner-wrap\";\n    capturePreviewFrame.style.zIndex = -100;\n    capturePreviewFrame.style.visibility = 'hidden';\n\n    let capturePreview = document.createElement(\"video\");\n    capturePreview.className = \"barcode-scanner-preview\";\n    capturePreview.msZoom = true;\n    capturePreview.style.height = 'calc(100%)';\n    capturePreview.style.top = 'calc(50%)';\n\n    capturePreviewFrame.appendChild(capturePreview);\n    document.body.appendChild(capturePreviewFrame);\n\n    preview = {};\n\n    preview.setVideoUrl = function (videoUrl) {\n      capturePreview.src = videoUrl;\n    }\n\n    preview.setMirroring = function (isMirrored) {\n      if (isMirrored) {\n        capturePreviewFrame.style.transform = 'scaleY(-1)';\n      } else {\n        capturePreviewFrame.style.transform = '';\n      }\n    }\n\n    preview.show = function () {\n        if (!capturePreviewFrame) {\n          return;\n        }\n\n        capturePreview.play();\n        capturePreviewFrame.style.visibility = 'visible';\n      }\n\n    preview.hide = function () {\n        if (!capturePreviewFrame) {\n          return;\n        }\n\n        capturePreviewFrame.style.visibility = 'hidden';\n        capturePreview.pause();\n      }\n\n    preview.pause = function() {\n        capturePreview.pause();\n      }\n\n    preview.resume = function() {\n        capturePreview.play();\n    }\n\n    preview.destroy = function () {\n        if (!preview) {\n          return;\n        }\n\n        preview = null;\n        document.head.removeChild(capturePreviewFrameStyle);\n        document.body.removeChild(capturePreviewFrame);\n    }\n\n    return preview;\n\n    }\n\n  module.exports = {\n    create: create\n  };\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-qrscanner/node_modules/cordova-plugin-qrscanner/src/windows/lib/qrScanner.js":"const videoCapture = require('./videoCapture');\nconst preview = require('./preview');\n\nconst barcodeReader = new QRReader.Reader();\n\nconst Promise = WinJS.Promise;\n\nconst errorTypes = {\n  UNEXPECTED_ERROR: 0,\n  CAMERA_ACESS_DENIED: 1,\n  CAMERA_ACCESS_RESTRICTED: 2,\n  BACK_CAMERA_UNAVAILABLE: 3,\n  FRONT_CAMERA_UNAVAILABLE: 4,\n  CAMERA_UNAVAILABLE: 5,\n  SCAN_CANCELED: 6,\n  LIGHT_UNAVAILABLE: 7,\n  OPEN_SETTINGS_UNAVAILABLE: 8\n};\n\nconst cameraTypes = {\n  BACK: 0,\n  FRONT: 1\n};\n\nfunction create() {\n\n  const defaultStatusFlags = {\n    prepared: false,\n    authorized: false,\n    denied: false,\n    restricted: false,\n    scanning: false,\n    previewing: false,\n    showing: false,\n    lightEnabled: false,\n    canOpenSettings: false,\n    canEnableLight: false,\n    canChangeCamera: false,\n    currentCamera: cameraTypes.BACK\n  };\n\n  function getDefaultStatusFlags() {\n    let statusFlags = {};\n    for (let property in defaultStatusFlags) {\n      statusFlags[property] = defaultStatusFlags[property];\n    }\n    return statusFlags;\n  }\n\n  let statusFlags = getDefaultStatusFlags();\n  let availableCameras;\n  let currentVideoCapture;\n  let currentPreview;\n\n  function generateStatusResponse() {\n    let response = {};\n    for (let property in statusFlags) {\n      response[property] = statusFlags[property] ? '1' : '0';\n    }\n    return Promise.wrap(response);\n  }\n\n  function init() {\n    if (!statusFlags.prepared) {\n      availableCameras = null;\n      statusFlags.currentCamera = null;\n      currentVideoCapture = null;\n      currentPreview = preview.create();\n      document.body.addEventListener('click', onPreviewClick);\n      return videoCapture.getCameras().then(function (cameras) {\n        if (cameras.back && cameras.front) {\n          statusFlags.canChangeCamera = true;\n        }\n        availableCameras = cameras;\n        return initCamera(cameraTypes.BACK).then(function () {\n          statusFlags.prepared = true;\n          statusFlags.authorized = true;\n        }, function (error) {\n          if (error.message.indexOf('Access is denied') > -1) {\n            statusFlags.denied = true;\n            return Promise.wrapError(errorTypes.CAMERA_ACESS_DENIED);\n          }\n          return Promise.wrapError(errorTypes.UNEXPECTED_ERROR);\n        });\n      });\n    }\n    return Promise.wrap();\n  }\n\n  function initCamera(cameraType) {\n    if (statusFlags.currentCamera !== cameraType) {\n      if (cameraType === cameraTypes.FRONT && !availableCameras.front) {\n        cameraType = cameraTypes.BACK;\n      }\n\n      return videoCapture.get(cameraType ? availableCameras.front.id : availableCameras.back.id).then(function (videoCapture) {\n        currentVideoCapture = videoCapture;\n\n        return Promise.join({\n          videoUrl: currentVideoCapture.getUrl(),\n          canEnableLight: currentVideoCapture.canEnableLight(),\n          capture: currentVideoCapture.getCapture()\n        }).then(function (result) {\n          if (statusFlags.showing) {\n            currentPreview.pause();\n          }\n          currentPreview.setVideoUrl(result.videoUrl);\n          currentPreview.setMirroring(cameraType === cameraTypes.FRONT);\n          if (statusFlags.showing) {\n            currentPreview.resume();\n          }\n          statusFlags.canEnableLight = result.canEnableLight;\n          statusFlags.currentCamera = cameraType;\n          barcodeReader.setCapture(result.capture);\n        });\n      });\n\n    }\n    return Promise.wrap();\n  }\n\n  function onPreviewClick(e) {\n    if (statusFlags.showing && currentVideoCapture) {\n      currentVideoCapture.focus();\n    }\n  }\n\n  let qrScanner = {};\n\n  qrScanner.getStatus = function () {\n    return init().then(generateStatusResponse, generateStatusResponse);\n  }\n\n  qrScanner.prepare = function () {\n    return init().then(generateStatusResponse);\n  }\n\n  qrScanner.useCamera = function (inputStr) {\n    return init().then(function () {\n      let cameraType = parseInt(inputStr)\n      return initCamera(cameraType).then(function () {\n        return generateStatusResponse();\n      });\n    });\n  }\n\n  qrScanner.show = function () {\n    return init().then(function (preview) {\n      currentPreview.show();\n      statusFlags.showing = true;\n      return generateStatusResponse();\n    });\n  }\n\n  qrScanner.hide = function () {\n    return init().then(function (preview) {\n      currentPreview.hide();\n      statusFlags.showing = false;\n      return generateStatusResponse();\n    });\n  }\n\n  let resolveLastScanPromise, rejectLastScanPromise;\n\n  qrScanner.scan = function () {\n\n    if (statusFlags.scanning) {\n      rejectLastScanPromise(errorTypes.SCAN_CANCELED);\n\n      let lastScanPromise = new Promise(function (resolve, reject) {\n        resolveLastScanPromise = resolve;\n        rejectLastScanPromise = reject;\n      });\n\n      return lastScanPromise;\n\n    }\n    statusFlags.scanning = true;\n\n    let lastScanPromise = new Promise(function (resolve, reject) {\n      resolveLastScanPromise = resolve;\n      rejectLastScanPromise = reject;\n    });\n\n    init().then(function () {\n      barcodeReader.readCode().then(function (result) {\n        if (!result) {\n          return rejectLastScanPromise(errorTypes.SCAN_CANCELED);\n        }\n        resolveLastScanPromise(result.text);\n        statusFlags.scanning = false;\n      });\n    });\n\n    return lastScanPromise;\n\n  }\n\n  qrScanner.cancelScan = function () {\n    statusFlags.scanning = false;\n    barcodeReader.stop();\n    return generateStatusResponse();\n  }\n\n  qrScanner.pausePreview = function () {\n    currentPreview.pause();\n    return generateStatusResponse();\n  }\n\n  qrScanner.resumePreview = function () {\n    currentPreview.resume();\n    return generateStatusResponse();\n  }\n\n  //on Lumia devices, light functionality may be disabled while plugged in\n  qrScanner.enableLight = function () {\n    return init().then(function () {\n      if (statusFlags.lightEnabled) {\n        return generateStatusResponse();\n      }\n\n      return currentVideoCapture.enableLight().then(function (lightEnabled) {\n        statusFlags.lightEnabled = lightEnabled;\n\n        if (!statusFlags.lightEnabled) {\n          return Promise.wrapError(errorTypes.LIGHT_UNAVAILABLE);\n        }\n\n        return generateStatusResponse();\n      });\n    });\n  }\n\n  qrScanner.disableLight = function () {\n\n    if (statusFlags.lightEnabled) {\n      return currentVideoCapture.disableLight().then(function () {\n        statusFlags.lightEnabled = false;\n        return generateStatusResponse();\n      });\n    }\n\n    return generateStatusResponse();\n\n  }\n\n  qrScanner.openSettings = function () {\n    return Promise.wrapError(errorTypes.OPEN_SETTINGS_UNAVAILABLE);\n  }\n\n  qrScanner.destroy = function () {\n    statusFlags = getDefaultStatusFlags();\n    if (currentPreview) {\n      document.body.removeEventListener('click', onPreviewClick);\n      currentPreview.destroy();\n    }\n    return generateStatusResponse();\n  }\n\n  return qrScanner;\n\n}\n\nmodule.exports = create();\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-qrscanner/node_modules/cordova-plugin-qrscanner/src/windows/lib/videoCapture.js":"  const Capture = Windows.Media.Capture;\n  const FocusMode = Windows.Media.Devices.FocusMode;\n  const Promise = WinJS.Promise;\n\n  let currentVideoCapture;\n\n  function create(videoDeviceId) {\n\n    let captureSettings = new Capture.MediaCaptureInitializationSettings();\n    captureSettings.streamingCaptureMode = Capture.StreamingCaptureMode.video;\n    captureSettings.photoCaptureSource = Capture.PhotoCaptureSource.videoPreview;\n    captureSettings.videoDeviceId = videoDeviceId;\n\n    let videoUrl;\n\n    let capture = new Windows.Media.Capture.MediaCapture();\n    let displayInformation = Windows.Graphics.Display.DisplayInformation.getForCurrentView();\n\n    let initPromise = capture.initializeAsync(captureSettings);\n\n    initPromise.then(function () {\n      adjustCaptureOrientation(displayInformation);\n      displayInformation.addEventListener(\"orientationchanged\", onOrientationChange);\n    });\n\n\n    canFocus().then(function (canFocus) {\n      let ctrl = capture.videoDeviceController;\n      if (canFocus && ctrl.focusControl.configure && ctrl.focusControl.supportedFocusModes) {\n\n        function supportsFocusMode(mode) {\n          return ctrl.focusControl.supportedFocusModes.indexOf(mode).returnValue;\n        }\n\n        var focusConfig = new Windows.Media.Devices.FocusSettings();\n        focusConfig.autoFocusRange = Windows.Media.Devices.AutoFocusRange.normal;\n        focusConfig.disableDriverFallback = false;\n        if (supportsFocusMode(FocusMode.continuous)) {\n          focusConfig.mode = FocusMode.continuous;\n        } else if (supportsFocusMode(FocusMode.auto)) {\n          focusConfig.mode = FocusMode.auto;\n        }\n      }\n    });\n\n    function onOrientationChange(e) {\n      adjustCaptureOrientation(e.target);\n    }\n\n    function adjustCaptureOrientation(displayInformation) {\n\n      let orientationDegrees = displayOrientationToDegrees(displayInformation.currentOrientation)\n\n      if (capture.getPreviewMirroring()) {\n        orientationDegrees = 360 - orientationDegrees;\n      }\n      capture.setPreviewRotation(degreesToCaptureRotation(orientationDegrees));\n    }\n\n    function displayOrientationToDegrees(displayOrientation) {\n      switch (displayOrientation) {\n        case Windows.Graphics.Display.DisplayOrientations.portrait:\n          return 90;\n          break;\n        case Windows.Graphics.Display.DisplayOrientations.landscapeFlipped:\n          return 180;\n          break;\n        case Windows.Graphics.Display.DisplayOrientations.portraitFlipped:\n          return 270;\n          break;\n        case Windows.Graphics.Display.DisplayOrientations.landscape:\n        default:\n          return 0;\n          break;\n      }\n    }\n\n    function degreesToCaptureRotation(degrees) {\n      switch (degrees) {\n        case 0:\n          return Windows.Media.Capture.VideoRotation.none;\n        case 270:\n          return Windows.Media.Capture.VideoRotation.clockwise270Degrees;\n        case 180:\n          return Windows.Media.Capture.VideoRotation.clockwise180Degrees;\n        case 90:\n        default:\n          return Windows.Media.Capture.VideoRotation.clockwise90Degrees;\n      }\n    }\n\n    function canFocus() {\n      return initPromise.then(function () {\n        if (capture.videoDeviceController) {\n          let ctrl = capture.videoDeviceController;\n          return ctrl.focusControl && ctrl.focusControl.supported;\n        }\n        return false;\n      });\n    }\n\n    let videoCapture = {\n      videoDeviceId: videoDeviceId\n    };\n\n    videoCapture.getUrl = function () {\n      return initPromise.then(function () {\n        if (!videoUrl) {\n          videoUrl = URL.createObjectURL(capture)\n        }\n        return videoUrl;\n      });\n    }\n\n    videoCapture.getCapture = function () {\n      return initPromise.then(function () {\n        return capture;\n      });\n    }\n\n    videoCapture.canEnableLight = function () {\n      return initPromise.then(function () {\n        if (capture.videoDeviceController) {\n          let ctrl = capture.videoDeviceController;\n          return (ctrl.flashControl && ctrl.flashControl.supported)\n            || (ctrl.torchControl && ctrl.torchControl.supported);\n        }\n        return false;\n      });\n    }\n\n    videoCapture.enableLight = function () {\n      return videoCapture.canEnableLight().then(function (canEnableLight) {\n        if (!canEnableLight) {\n          return false;\n        }\n\n        function lightEnabler(lightControl) {\n          if (lightControl && lightControl.supported) {\n            lightControl.enabled = true;\n            if (lightControl.powerSupported) {\n              lightControl.powerPercent = 90;\n            }\n            return true;\n          }\n          return false;\n        }\n\n        if (capture.videoDeviceController) {\n          let ctrl = capture.videoDeviceController;\n\n          let flashEnabled = lightEnabler(ctrl.flashControl);\n          let torchEnabled = lightEnabler(ctrl.torchControl);\n\n          return flashEnabled || torchEnabled;\n        }\n        return false;\n      });\n    }\n\n    videoCapture.disableLight = function () {\n      return videoCapture.canEnableLight().then(function (canEnableLight) {\n        if (!canEnableLight || !capture.videoDeviceController) {\n          return;\n        }\n\n        let tc = capture.videoDeviceController.torchControl;\n        let fc = capture.videoDeviceController.flashControl;\n\n        if (tc.enabled) {\n          tc.enabled = false;\n        }\n        if (fc.enabled) {\n          fc.enabled = false;\n        }\n      });\n    }\n\n    videoCapture.focus = function () {\n      const OPERATION_IS_IN_PROGRESS = -2147024567;\n      const INITIAL_FOCUS_DELAY = 200;\n\n      canFocus().done(function (canFocus) {\n        if (canFocus) {\n          let focusControl = capture.videoDeviceController.focusControl;\n          if (focusControl.focusState !== Windows.Media.Devices.MediaCaptureFocusState.searching) {\n            Promise.timeout(INITIAL_FOCUS_DELAY).done(function(){\n              focusControl.focusAsync().onerror = function (error) {\n                if (error.number !== OPERATION_IS_IN_PROGRESS) {\n                  console.error(error);\n                }\n              };\n            });\n\n\n          }\n        }\n      });\n    }\n\n    videoCapture.destroy = function () {\n      return initPromise.then(function () {\n        displayInformation.removeEventListener(\"orientationchanged\", onOrientationChange);\n      });\n    }\n\n    currentVideoCapture = videoCapture;\n    return videoCapture;\n\n  }\n\n  function getCameras() {\n    var Devices = Windows.Devices.Enumeration;\n\n    return Devices.DeviceInformation.findAllAsync(Devices.DeviceClass.videoCapture)\n    .then(function (cameras) {\n\n      if (!cameras || cameras.length === 0) {\n        throw new Error(\"No cameras found\");\n      }\n\n      let backCameras = cameras.filter(function (camera) {\n        return camera.enclosureLocation && camera.enclosureLocation.panel === Devices.Panel.back;\n      });\n      let frontCameras = cameras.filter(function (camera) {\n        return camera.enclosureLocation && camera.enclosureLocation.panel === Devices.Panel.front;\n      });\n\n      return {\n        back: backCameras[0] || cameras[0],\n        front: frontCameras[0]\n      };\n    });\n  }\n\n  module.exports = {\n    get: function (videoDeviceId) {\n      if (currentVideoCapture) {\n        if (currentVideoCapture.videoDeviceId === videoDeviceId) {\n          return Promise.wrap(currentVideoCapture);\n        }\n        currentVideoCapture.destroy().then(function () {\n          return create(videoDeviceId);\n        });\n      }\n      return Promise.wrap(create(videoDeviceId));\n    },\n    getCameras: getCameras\n  };\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-qrscanner/node_modules/cordova-plugin-qrscanner/src/windows/lib/qrScannerProxy.js":"const qrScanner = require('./qrScanner');\n\nlet proxy = {};\n\nfunction wrap(fn) {\n  return function (successCallback, errorCallback, strInput) {\n    fn.call(qrScanner, strInput).then(successCallback, function (errorCode) {\n      errorCallback(errorCode.toString() || '0');\n    });\n  }\n}\n\nfor (let property in qrScanner) {\n  if (typeof qrScanner[property] == \"function\") {\n    proxy[property] = wrap(qrScanner[property])\n  }\n}\n\nmodule.exports = proxy;\n\ncordova.commandProxy.add(\"QRScanner\", proxy);\n"}